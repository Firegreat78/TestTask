# TestTask
Тестовое задание Cloud.ru

# Вводная:
Меня зовут Медведев Даниил, мне 19 лет. Студент 2-го курса.

Телефон: +79967065791

Телеграм: @Firegreat

Почта: dmedvedev947@gmail.com

В данный момент нахожусь не в Москве. Готов к переезду в Москву в случае успешного прохода на стажировку, так как предпочитаю очный формат.

# Вопросы:
##1. Расскажите, с какими задачами в направлении безопасной разработки вы сталкивались?

Ответ: на данный момент – никакими.

## 2. Если вам приходилось проводить security code review или моделирование угроз, расскажите, как это было?

Ответ: пока ещё не приходилось. Это первый раз.

## 3. Если у вас был опыт поиска уязвимостей, расскажите, как это было?

Ответ: такого опыта пока что не было.

## 4. Почему вы хотите участвовать в стажировке?

Ответ: Во-первых, я хочу учавствовать потому, что мне интересно, насколько быстро я смогу схватывать новую для информацию. Во-вторых, потому, что выполнение тестового задания – плюс в копилку портфолио, что увеличивает мои шансы на будущее трудоустройство. Очень полезно знать, с чем придётся иметь дело, ведь тестовые задания в некоторой мере отражают суть того, чем занимаются люди на рабочих местах. Чем на большее количество стажировок откликнусь – тем больше получу тестовых заданий и тем больше буду понимать, в каких направлениях стоит развиваться.

# 1. Security code rewiew (Go)

Одной из уязвимостей, присутствующих в этом фрагменте кода, является SQL Injection (внедрение кода SQL).

Строка кода, которая соответствует данной уязвимости: `query := fmt.Sprintf("SELECT * FROM products WHERE name LIKE '%%%s%%'", searchQuery)`

Последствия SQL Injection следующие: злоумышленник, подобрав часть SQL запроса, подходящую под исходный код приложения, может извлечь из базы данных буквально любую информацию, например, отобрав записи по условию ”или 1=1” (заведомо истинному выражению, вследствие чего запрос вернёт абсолютно все записи в таблице) и закомментировав правую часть запроса; модифицировать базу данных (удалить, изменить любые её данные или реляционные связи между таблицами).
## Способы устранения этой уязвимости и их описание:
### 1. Выдача такого уровня привилегий, которой будет достаточно только для доступа к данным (например, row level security, ограничение прав на изменение базы данных или таблицы). 

Ограничение прав на изменение базы данных, таблицы, прочтения других записей не позволит злоумышленникам, например, удалить таблицу, изменить отношения между ними, извлечь лишнюю информацию. Но в случае, когда нужно авторизоваться в аккаунт с веб-страницы авторизации, у неё должен быть доступ ко всем логинам и паролям, так как с этой страницы должна быть возможность авторизоваться в любой из существующих аккаунтов системы, а следовательно, и доступ на чтение всех логинов и паролей, откуда следует вероятность утечки (отсутствие прав на чтение базы данных с главной страницы авторизации с последующим редиректом на специальную веб-страницу с дополнительными правами не поможет, поскольку URL этой страницы в любом случае будет известен злоумышленникам и в любом случае они смогут через него получать такой же доступ к данным, как если бы его не было, осуществив SQL – инъекцию через адресную строку). Row level security же будет работать только в том случае, когда пользователь уже вошёл в аккаунт и веб-страница имеет информацию о логине авторизованного пользователя и поэтому не предоставит доступа к чужой информации.

Однако если рассматривать случай, когда в базе данных хранятся хешированные пароли, то, на первый взгляд кажется, что веб-страница авторизации защищена от взлома и утечек. Но в случае, если используются простые, популярные и известные алгоритмы хеширования, то уязвимость никуда не пропадёт: злоумышленник сможет перебором определить алгоритм, который используется для хеширования паролей, и дешифровать все извлечённые хешированные пароли. Если же хешировать пароли очень стойким криптографическим шифром, то, если эта практика используется корпорациями, для которых утечка данных не столь критична и не принесёт значительного ущерба пользователям, либо теми, которые не являются главной целью хакеров, то это будет являться вполне рациональным решением. Однако, например, для банков, сервисов Google, Пентагона, финансовых бирж и других корпораций, для которых утечка данных будет очень критична как для самой корпорации, так и для пользователей, этот метод крайне не рекомендуется, поскольку именно эти корпорации являются главной целью хакеров, которые вкладывают огромные усилия для их взлома. Это означает, что существует шанс того, что тот или иной криптографический шифр, пусть самый сложный и никому не известный, кроме сотрудников самой корпорации, может оказаться взломан одним из множества хакеров.

Вывод: этот метод неуниверсален и подходит только для следующих случаев (если система подходит под второй случай – ограничение прав доступа более чем рационально):
1. Система не является целью большого кол-ва хакеров (заметим, что намеренно снижать безопасность системы в этом случае – плохая идея, лучше выбрать более безопасный метод);

2. Пользователь уже вошёл в систему.

### 2. Валидация введённых пользователем данных. 
Этот метод является довольно сложным, если целью является идеальная реализация (необходимо проверить все ключевые слова SQL, такие их комбинации, которые потенциально способны привести к утечке данных или изменению таблицы в базе данных, а таковых очень много), Если упустить хотя бы одну какую-либо комбинацию – система будет уязвима к SQL - инъекции, особенно в том случае, когда злоумышленник очень опытный и пишет очень хитрые комбинации в поля ввода. Кроме того, при чтении кода, использующего валидацию, неочевидно будет понять, какие потенциальные случаи SQL - инъекции уже были предотвращены валидацией, а какие – ещё нет. Это усложнит задачу поиска всевозможных случаев, которыми может в теории воспользоваться злоумышленник, то есть замедлит написание защитного кода. Однако если не стремиться к идеалу, то можно заметить, что этот способ может покрыть большое количество вариантов инъекций, что делает его использование вполне разумным.

Вывод: способ является универсальным и рабочим при идеальной реализации, но так как достичь идеала и предусмотреть всевозможные варианты инъекции сложно, крайне не рекомендуется ограничиваться только этим методом. Однако он способен покрыть большое количество возможных вариантом, что делает его обязательным к применению.

### 3. Хранимые процедуры

Хранимые процедуры – заранее скомпилированные наборы SQL-инструкций, хранящиеся на сервере. Они позволяют избежать SQL-инъекции в тех случаях, когда набор SQL – инструкций заранее определён, поскольку хранимые процедуры заранее скомпилированы и злоумышленник не сможет добавить в них новые инструкции или изменить старые. Однако если хранимые процедуры формируют вложенный SQL-запрос с помощью конкатенации аргументов, вводимых пользователем, то такая процедура не будет являться безопасной (набор SQL – инструкций во вложенном запросе не определён заранее и зависит от ввода пользователя, следовательно, злоумышленник имеет возможность создавать вложенный SQL – запрос по своему усмотрению) даже несмотря на то, что такая SQL – инъекция будет менее гибкой.
Вывод: хранимые процедуры позволяют избежать SQL-инъекции только в том случае, когда когда они описывают несложную логику, следовательно, данный способ решения не является универсальным.

### 4. Библиотеки ORM

Библиотеки ORM используются для описания SQL-запросов с помощью средств языка программирования, отличного от SQL. Они предоставляют повышенный уровень абстракции и позволяют защитить систему от SQL – инъекций, так как методы этих библиотек рассматривают переданные параметры не как часть SQL-запроса, а как “данные”, что не позволит, например, вставить комментарий в SQL-запрос или реализовать собственную логику. Логика полностью определена теми методами библиотек ORM, которые написал программист в исходном коде системы. Однако у этого метода есть недостаток: в случае SSTI (Server Side Template injection) злоумышленник может использовать их для извлечения данных даже не прибегая к скачиванию и установке этих библиотек (они уже установлены, поскольку используются), причем полностью ограничить доступ в данном случае не является возможным, поскольку необходим минимальный уровень доступа для совершения операций, задуманных программистом (например, в случае веб-страницы авторизации в аккаунт, необходим доступ ко всем логинам и паролям, хранящимся в базе данных, поэтому не представляется возможным изъятие прав на чтение этих самых логинов и паролей. Несмотря на то, что можно изъять права на редактирование базы данных или на чтение других таблиц, полная безопасность не обеспечена).
Вывод: способ является рабочим и универсальным, но в случае SSTI он может быть использован злоумышленником как инструмент для совершения SQL – инъекции. Также из-за высокого уровня абстракции не всегда очевидна расшифровка SQL-запроса, который в итоге формируется при использовании библиотек ORM, особенно в случае если запрос имеет очень сложную структуру. Не рекомендуется к использованию, если присутствует риск SSTI.

### 5. Prepared statements (parameterized queries, подготовленные выражения)
Подготовленные выражения – метод для предотвращения SQL-инъекций, основанный на создании шаблона, в который подставляются определённые данные (как форматированная строка в Python, C# или Java), причём эти данные не рассматриваются как часть SQL-запроса (так же, как и в библиотеках ORM). Главное отличие подготовленных выражений от библиотек ORM состоит в том, что для создания этих выражений требуется создать шаблон в виде SQL-запроса (отсутствие слоя абстракции в противоположность библиотекам ORM). Отсутствие слоя абстракции позволяет видеть перед глазами всю логику SQL-запроса, каким бы сложным он ни был, а также повышает гибкость при написании и редактировании шаблона.
Подготовленные выражения также можно использовать и внутри хранимых процедур (принцип тот же самый), что позволяет, помимо обеспечения защиты системы, ещё и ускорить написание кода.

Вывод: метод является универсальным, простым в реализации (нужно уметь писать SQL - запросы), и надёжным, а отсутствие слоя абстракции позволяет программисту легче ориентироваться в коде. Если программа будет рассматривать вводимые человеком данные в полях для ввода строго как значения, подставляемые в шаблон, а не как часть SQL-запроса, то вероятность SQL – инъекции снизится до 0%.

Главный вывод: из 5 рассмотренных методов предотвращения SQL-инъекции универсальными (то есть рабочими в любых условиях) являются 3: валидация данных, использование библиотек ORM, и подготовленные выражения. Используя только метод валидации данных, снизить вероятность SQL-инъекции до 0% практически невозможно, поскольку нужно учесть абсолютно все возможные сценарии внедрения SQL-кода. Однако существуют ещё два метода предотврашения инъекций. Оба они являются универсальными, однако я бы склонился в сторону подготовленных выражений, так как, во-первых, они не могут быть использованы злоумышленниками в случае SSTI, что повышает общую безопасность, а во-вторых, ввиду отсутствия слоя абстракции перед глазами программистов будет шаблон SQL – запроса, который позволит им легче ориентироваться и понимать структуру запроса и баз данных, используеых в приложении. Используя валидацию данных и подготовленные выражения, можно снизить риск инъекции практически до нуля.

## Остальные уязвимости, связанные с безопасностью:

### 1. Использование протокола HTTP.
Строка кода, отвечающая за использование HTTP: `log.Fatal(http.ListenAndServe(":8080", nil))`, а именно следующая её часть: `http.ListenAndServe(":8080", nil)`

Во-первых, протокол HTTP на шифрует данные, в отличие от протокола HTTPS. Это влечёт риск перехвата данных. Во-вторых, протокол HTTPS предоставляет механизм для клиентов проверки идентичности серверов, к которым они подключаются. Это помогает предотвратить подключение пользователей к поддельным веб-сайтам, разработанным для кражи информации.
Для исправления уязвимости следует обрести сертификат TLS и ключ (это обязательно для деплоя в продакшн), затем использовать функцию http.ListenAndServeTLS вместо http.ListenAndServe, куда нужно будет передать сертификат TLS и ключ.

# 2.1. Python code review.

Синтаксические ошибки, не связанные с безопасностью, откоментированы ниже.
```
from flask import Flask, request
from jinja2 import Template

app = Flask(__name__) # неверное указание имени

@app.route("/page")
def page():
    name = request.values.get('name')
    age = request.values.get('age', 'unknown')
    output = Template('Hello ' + name + '! Your age is ' + age + '.').render()
    return output # отсутствие индентации

if __name__ == "__main__": # неверное указание имени
    app.run(debug=True)
```
Главной уязвимостью фрагмента кода является Server-Side Template Injection (SSTI, внедрение шаблонов на стороне сервера). Отличие SQL – инъекции от SSTI заключается в том, что первая направлена на базы данных (изменение данных таблиц или отношений между ними), а вторая – на веб-приложения, использующие шаблонизаторы для генерации HTML-страниц. Используя SSTI, злоумышленник может внедрить произвольный код (в данном случае – код Python), который будет выполняться на стороне сервера. Это может привести к следующим последствиям:

## 1. Нагрузка сервера. 

Злоумышленник может внедрить код, выполнение которого тратит очень много вычислительных ресурсов сервера, из-за чего его КПД сильно упадёт и он будет тормозить, а в худшем случае – откажет работать и упадёт.

## 2. Доступ в интернет со стороны сервера.

Злоумышленник может получить доступ к произвольной веб-странице, и скачать практически любые файлы, внедрив соответствующий код. Отсюда следует, что:

2.1. Злоумышленники могут установить на сервер вредоносную или шионскую программу, которая может как и целенаправленно нарушить работоспособность сервера, так и в фоновом режиме собирать данные о нём.

2.2. Злоумышленник может установить на сервер библиотеки языка программирования (например, ORM - библиотеки), позловяющие осуществить SQL – инъекцию.

## 3. Взаимодействие с командной строкой.
Оно же Command injection. Имеется возможность выполнить произвольные команды оболочки, используя средства языка Python

Строка кода, заключающая в себе уязвимость SSTI: `output = Template('Hello ' + name + '! Your age is ' + age + '.').render()`

Здесь строка для вывода собирается из аргументов, переданных на сервер пользователем, форма шаблона не определена заранее. Поскольку шаблон конструируется с помощью класса Template, в нем не включен autoescaping (преобразование определённых символов, которые могут быть восприняты как часть страницы HTML, или как часть кода JavaScript, в соответствующие им безопасные кодовые последовательности), а также он не является безопасным шаблоном (имеется возможность внедрить набор символов, которые будут преобразованы в выполняемый код).

## Способы предотвращения SSTI:

### 1. Валидация введённых пользователем данных.

Так же как и в примере с Go, чтобы валидация предотвращала все возможные варианты SSTI, необходимо писать огромное множество проверок и учитывать все возможные варианты кода, выполнение которого способно привести к SSTI, что не является лучшей идеей, поскольку есть высокая вероятность упустить какую-либо из возможных комбинаций, что оставит шанс злоумышленникам воспользоваться не до конца устранённой уязвимостью. Однако большее количество вариантов будут предотвращены, что делает этот способ рекомендуемым к реализации.

Вывод: способ универсален, рекомендуется к применению в тандеме с остальными для смягчения рисков инъекции.

### 2. Генерация безопасных шаблонов.

С помощью метода render_template_string фреймворка flask можно конструировать заранее определённые шаблоны таким образом, что в них в определённые места (placeholders) можно вставлять определённые данные, причём эти данные не будут рассматриваться как исходный код Python (похожим образом работают подготовленные выражения против SQL – инъекций). Также он поддерживают механизм autoescaping.

Вывод: способ прост и универсален, хорошо защищает от риска инъекции.

### 3. Ограничение прав хоста сервера.

Ограничение прав хоста предотвратит возможность скачивания файлов на сервер или выполнение определённых команд оболочки со стороны сервера.

Вывод: Быстрая, простая и полезная превентивная мера в данном случае. Не позволит злоумышленникам получить доступ в интернет или изменить параметры системы.

Главный вывод: все три способа здесь играют важную роль в защите системы. Наиболее рациональным решением в данном случае будет использовать все три защитных механизма для минимизации риска SSTI.

Ещё одна уязвимость в данном фрагменте кода – режим отладки при запуске приложения. Программа, запущенная в режиме отладки, будет сообщать подробные сообщения об ошибках, которые включают: использованные функции и методы, имена файлов, номера строк кода, где произошла ошибка и т. д. Владея этой информацией,  злоумышленник сможет более подробно представлять в голове “архитектурный” план системы, как она написана. Это позволит ему легче находить различные уязвимости системы.
Режим отладки включён здесь: `app.run(debug=True)`

Решение: не использовать режим отладки в продакшене.

# 1.2.2. Python code review.
Ошибки, не связанные с безопасностью:

Как и в первом примере, отсутствует индентация строки, возвращающей зачение из функции, и забыты два нижних подчёркивания до и после слов “main” и “name”. Здесь также включен режим отладки приложения Flask. Способы устранения проблем идентичны.

Здесь присутствует следующая уявзимость - Command Injection (внедрение команды). Заключается в том, что злоумышленник имеет возможность выполнить произвольную команду на сервере, используя оболочку (командную строку). 

Строки, несущие уязвимость:
```
cmd = 'nslookup ' + hostname
output = subprocess.check_output(cmd, shell=True, text=True)
```
Во-первых, в функции check_output() не следует задавать значение аргумента shell=True, так как в этом случае Python запустит оболочку и будет выполнять команды в ней, следовательно, злоумышленник может внедрить произвольный код и получить доступ и возможность изменять параметры оболочки и/или сервера (в том числе переменных окружения), получить доступ в интернет и скачать вредоносные программы, попытаться удалить файлы и так далее (то есть расширяется потенциальный вектор атаки). При значении аргумента shell=False, аргументы передаются системе, минуя оболочку, что не даст злоумышленнику добраться до переменных окружения, использовать команды оболочки. Однако этого недостаточно для полного устранения уязвимости.

Во-вторых, при создании команды cmd была использована конкатенация строки с параметром. Даже если аргументы будут переданы операционной системе, а не оболочке, это может не спасти от внедрения команд, так как не факт, что операционная система распознает получившуюся конкатенированную строку как единую команду. Если операционная система распознает наличие других команд, атака злоумышленника увенчается успехом. 

Для устранения уязвимости следует, во-первых, не использовать оболочку для выполнения команд, а во-вторых, передавать в качестве аргумента cmd в функцию check_output() список строк, где первая строка в списке – сама команда, переданная системе, а все последующие элементы списка – её аргументы. Это снизит вероятность внедрения произвольных команд и манипуляций с системой до нуля.
 
# 2. Моделирование угроз:

2.1. Расскажите, какие потенциальные проблемы безопасности существуют для данного сервиса?
Потенциальные проблемы безопасности следующие:

2.1.1. Небезопасная аутенфикация (возможность создания небезопасных паролей, отсутствие двухфакторной аутенфикации, небезопасная система восстановления паролей и так далее).

2.1.2. Возможность перехвата пользовательских данных при их передаче с клиента на сервер. 

2.1.3. Уязвимость хранимых данных (относится к S3, PostgreSQL, переменным окружения и т. д.)

2.1.4. Некорректно настроенные права доступа к внешним сервисам (Slack, Telegram).

2.1.5. Возможность DDoS – атаки.

2.2. Расскажите, к каким последствиям может привести эксплуатация проблем, найденных вами?

2.2.1. Возможность создания небезопасных паролей приводит к потенциальному взлому некоторых аккаунтов с лёгкими для взлома паролями; отсутствие двухфактороной аутенфикации снижает уровень безопасности пользователей сервиса и может способствовать взлому аккаунтов в случае, если злоумышленники завладели паролями в случае, например, SQL – инъекции; небезопасная и ненадёжная система восстановления паролей позволит злоумышленникам легко присваивать себе чужие взломанные аккаунты.

2.2.2. Утечка незашифрованных данных приведёт к тому, что злоумышленники смогут завладеть практически любой информацией, вплоть до информации из любых приватных чатов. Люди в процессе общения в системе могут рассказывать информацию о себе, что приведёт к её утечке.

2.2.3. Небезопасное хранение привести к данных, связанных с самой системой (например, переменные окружения сервера или данные в БД). В случае если bucket внутри Amazon S3 открыт для публичного доступа – статические данные вроде переменных окружения могут быть изъяты злоумышленниками, что может систему ещё более уязвимой. А если БД уязвима к SQL – инъекции, злоумышленники смогут получить данные и о данных в БД.

2.2.4. Некорректно настроенные права доступа позволят злоумышленникам создать бота, а затем, используя API, использовать этого бота для отправки произвольных уведомлений. Также, если API не настроен на медленный режим (не установлен лимит на допустимое количество обращений в заданный промежуток времени), то имеется возможность тормозить его работу (перекликается с DDoS – атакой).

2.2.5. DDoS – атака влечёт нагрузку на сервер, вследствие чего он будет работать медленно, а в худшем случае – упасть.

2.3. Расскажите, какие способы исправления уязвимостей и смягчения рисков вы можете предложить по отмеченным вами проблемам безопасности?

2.3.1. Использование двухфакторной аутенфикации, невозможность ввода слишком лёгких для взлома паролей, автоматическая заморозка аккаунтов, которые подозреваются во взломе, а также развёртка надёжной и оперативной службы поддержки, которая будет своевременно помогать пользователям чьи аккаунты оказались взломаны или находятся под подозрением взлома.

2.3.2. Использование протокола HTTPS, который шифрует данные перед отправкой, не позволит их перехватить. 

2.3.3. Для смягчения рисков утечки важных данных и параметров системы следует ограничивать доступ к bucket’ам S3 и БД PostgreSQL, а также предотвращать возможность инъекций (SQL – инъекций для предотвращения доступа к БД, инъекций кода и команд – для предотвращения доступа к параметрам системы). Ещё нужно обязательно хешировать важные данные очень надёжным криптографическим шифром.

2.3.4. В качестве превентивной меры для ограничения доступа к API: следует задавать ключи API, используя переменные окружения, а не исходный код программы, что снизит шансы извлечь их из кода. В комбинации с другими мерами, не позволяющими получить доступ к переменным окружения, обеспечит наивысшую безопасность.

2.3.5. Для предотвращения DDoS – атаки разумно установить лимит интернет трафика, устранить возможность инъекций кода и ограничить количество запросов, которые могут быть переданы API за определённый промежуток времени.

2.4. Напишите список уточняющих вопросов, которые вы бы задали разработчикам данного сервиса?

2.4.1. Как обрабатывается аутентификация и какие меры предпринимаются для предотвращения атак методом подбора или использования украденных учетных данных?

2.4.2. Шифруются ли данные при передаче между всеми компонентами системы? Какие протоколы используются?

2.4.3. Как хранятся и управляются чувствительные учетные данные для доступа к внешним сервисам?

2.4.4. Имеются ли механизмы ограничения частоты запросов для предотвращения злоупотребления API сервиса?

2.4.5. Как ограничен и контролируется доступ к S3-корзине (bucket) и базе данных PostgreSQL?

2.4.6. Какие решения для ведения журналов и мониторинга используются для обнаружения подозрительных действий? (регулярный мониторинг позволит быстрее заметить подозрительные активности и принимать меры наперёд)

2.4.7. Как часто проводятся аудиты безопасности и тесты на проникновение в БД, хранилище S3 или через API?

2.4.8. Имеются ли автоматизированные инструменты или процессы для сканирования уязвимостей и управления патчами? (нужно для того, чтобы система использовала новейшие версии библиотек и модулей)

2.4.9. Как вилидируется пользовательский ввод для предотвращения атак c помощью инъекций?
